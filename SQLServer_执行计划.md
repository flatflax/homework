# SQL Server execution plan

之前在SQL Server中某个T-SQL的优化讨论中看到了该SQL的执行计划文件(`*.sqlplan`后缀的文件)。由于之前没有接触过相关的信息，所以在这里对执行计划作了一些资料的整理。

## SQL Server 执行计划  Execution Plan

查询优化器根据T-SQL语句，通过计算而选择出效率最高的一种执行方案。这种执行方案被称为执行计划。执行计划可以通过图形化界面、文本、XML的方式查看。从执行计划，我们可以得知这个查询语句如何被执行，并从中得知哪个部分效率较低。

### T-SQL处理过程

T-SQL主要通过两个阶段被处理：关系引擎阶段和存储引擎阶段。在执行计划中，主要关注关系引擎阶段。

* 关系引擎阶段：确保query被正确解析，然后交给查询优化器并产生执行计划。执行计划以二进制格式发到存储引擎来更新或者读取数据。

* 存储引擎阶段：主要处理的内容如锁、索引的维护和事务等。

### Query Parsing 查询解析

查询解析发生在关系引擎上，检查SQL语句是否正确。如果能够顺利解析，会生成一个"解析树"，解析书能够呈现SQL语句的逻辑步骤。假如SQL语句不是DML类型，就不需要被优化。

### 查询优化器

根据解析树和有关数据的统计信息，计算出效率较高的执行计划。SQL Server维护的统计数据有目标对象上的数据列、索引、唯一性等。在计算出执行计划的过程中会生成成本估算(Estimated Cost)。得出的执行计划会在"缓存计划"的内存空间中创建。假如缓存计划中不存在执行计划，则直接创建；存在则使用先有的缓存计划。

### 查询执行

当执行计划被创建后，会在存储引擎中按照执行计划，真正地执行该T-SQL。

### 估算执行计划和实际执行计划   Estimated and Actual Execution Plans

* 估算执行计划：由查询优化器生成
* 实际执行计划：执行"估算执行计划"后的真实结果。属于存储引擎。

## 执行计划的重用、清除和重新编译

* 执行计划的重用：对比由查询优化器生成的"估算执行计划"和缓存计划中的计划。
* 执行计划的清除：在某些条件下，SQL Server会释放相关内存：

	* 系统需要更多的内存
	* 该执行计划的倒数计数器为0
	* 没有链接引用该执行计划

也可以使用`DBCC FREEPROCCACHE`清除缓存

* 执行计划的重新编译
	
	* Query所用的表或结构发生变化
	* Query所用的索引发生变化
	* 调用sp_recompile

## 查看现有的执行计划

	SELECT [cp].[refcounts]
	,[cp].[usecounts]
	,[cp].[objtype]
	,[st].[dbid]
	,[st].[objectid]
	,[st].[text]
	,[qp].[query_plan]
	FROM sys.dm_exec_cached_plans cp
	CROSS APPLY sys.dm_exec_sql_text(cp.plan_handle) st
	CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle)
	qp

## 部分成本情况

### 估算执行计划

* Cached plan size – 在存储过程缓存中由这个查询语句产生的计划所占用内存的大小, 这个数字比较有用, 可以用来调查缓存的性能问题, 特别是某个计划所占的内存非常大的情况下.

* Estimated Operator Cost – 该操作的耗费

* Estimated Sub tree Cost – 告诉我们这个步骤和之前所有的步骤所累加起来的一个耗费值, 但是看它之前的步骤要注意要从右往左读, 目前 SELECT 步骤的左边没有其他的步骤. 这个值表示的是查询优化器认为这个运算符可能要花费的时间.

* Estimated number of rows – 查询优化器基于一些统计数据得到的, 这里指的是返回的行数.

---

### 实际执行计划

* Logical Operations – 查询优化器认为对在 Query 语句执行时应该发生的操作 .

* Physical Operations – 实实在在发生的操作. 这两个值大多数情况相同, 但也有不同的时候.

* Estimated number of rows – 再次看到这个值, 实际上每一个步骤的操作可能不相同, 每一个步骤要处理和传递的数据量大小都不一样, 所以从每个步骤中就能看到数据量大小的变化, 有哪些增加了, 有哪些被过滤掉了, 这样也会帮助我们理解整个流程发生了什么.

* Ordered – 告诉我们这个步骤的操作符是否对数据进行了排序操作.

