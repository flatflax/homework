# 并发

在计算机中，程序可能会因为I/O限制和CPU限制而处于等待的状态。当处理需要长时间执行的任务，如上传文件、查询数据库等时，使用同步的方式，就难免会产生等待。这个时候就可以异步地并发执行。

### 队列

队列是FIFO(先进先出)的。通常使用队列来传递信息，我们可以使用队列管理分布式任务。在这种情况下，队列被称为工作队列或任务队列。

### 进程

可以使用标准库中`multiprocess.Queue()`来在进程中实现队列。`terminate()`来结束进程。

进程拥有独立的内存单元和独立的地址空间(私有的、虚拟的)。但是进程之间的切换需要花费较多的时间。

### 线程

线程运行在进程的内部，可以访问进程内的所有内容。可以使用threading来实现线程。

同一个进程中的线程共享内存，线程拥有一个应用程序的入口，顺序执行序列和出口。但操作系统不会对线程进行调度、管理、资源分配，也不存在类似`terminate()`的方法来结束线程。

就像C 和C++ 这类语言中的手动内存管理一样，线程可能会引起很难寻找和处理的bug。要使用线程，程序中的所有代码——以及程序使用的所有外部库中的代码——必须是线程安全的。

常见的安全共享数据的方法是让线程在修改变量之前加软件锁，这样在进行修改时其他
线程都会等待。

但是在Python中不能使用线程来实现CPU加速，因为Python中使用了GIL(全局解释器锁)，来避免Python中的线程问题。因此在受CPU限制的任务中，使用多线程的处理速度可能会比使用多进程或单线程更慢。

总结来说，在Python中，建立使用线程来解决I/O限制，使用线程、网络或事件来解决CPU限制。

### 协程 绿色线程

除了使用多进程和多线程的方式来解决程序运行过慢的问题，还可以使用基于事件编程的方式。一个基于事件的程序会运行一个核心事件循环，分配所有任务，然后重复这个循环。Nginx就是使用基于事件的设计。

我们可以使用第三方包gevent来生成协程。协程就像可以互相通信的生成器，它们会记录自己的位置。gevent 可以修改许多Python的标准对象，比如socket，从而使用它自己的机制来代替阻塞。但协程无法处理C 写成的Python 扩展代码，比如一些数据库驱动程序。

`gevent.spawn()`会为每个`gevent.socket.gethostbynome(url)`创建一个绿色线程（也叫微线程）。绿色线程(Green Thread)是对应操作系统线程(Native Thread)产生的概念。绿色线程由语言运行平台自身来调度，不同的语言下不一定会映射到操作系统的线程。例如在Python中，绿色线程会映射到操作系统(Ruby中则不会)，如果遇到会阻塞操作系统线程的情况，gevent会自动将控制权切换到其他的绿色线程。

### twisted

twisted是一个异步事件驱动的网络框架。我们可以把函数关联到事件（比如数据接收或者连接关闭）上，当事件发生时这些函数会被调用。这种设计被称为回调（callback）。

### asyncio

asyncio 模块在Python 3.4 中首次出现。它提供了一种通用的事件循环，可以兼容twisted、gevent和其他异步方法。目标是提供一种标准、简洁、高性能的异步API。