数据库中常说的索引为B-Tree索引，大多数存储引擎都支持这种索引。但不同的存储结构可能会使用不同的数据结构来实现索引。MySQL普遍使用B+Tree(B-Tree的变种)实现索引结构。



### 二叉查找树的特点

左子树小于根，右子树大于根
二叉查找树的平均查找速度大于顺序查找
**平衡二叉树**的查询性能最高，但相应的维护成本也很高。

### 平衡二叉树的旋转

* 任何节点，两个子数的高度差不能大于1

当插入新值时，可以通过对子树和子节点进行旋转而保证平衡

例：新插入值8

(旋转前)

	6
	 \
	  7
	   \
	    8
(旋转后)

	  7
	 / \ 
	6   8


### m-way查找树的特点

随着数据库表中数据的增加，索引的大小也随之增加。这个时候就需要索引以索引文件的形式存储在磁盘上。每次进行索引查找时，就会产生I/O存取消耗。但I/O存取消耗远比内存存取消耗高。将高深度的二叉树放在磁盘中，每次读取的耗时极大。因此需要减少在查找过程中对I/O存取次数。

其中一种办法是将二叉树变成m-way查找树(多路搜索树).m-way查找树的m意味着树中每个节点的度小于等于m。m-way查找树的特点如下：

* 每个节点的键值小于m
* 每个节点的度(子树数量)小于m
* 键值按顺序排列
* 子数的键值完全小于/大于/介于父节点之间的键值

### B-Tree的特点

B-Tree是一种平衡的m-way搜索树。B是Balance的意思。

* 每个结点的子结点个数≤m
* 根结点若不是叶子结点，它至少有两个子结点
* 除根和叶子结点外，每个结点的子结点个数≥ [m/2]
* 所有的叶子结点都出现在同一层，而且不带有信息
* 非叶子结点若具有j+1个子结点，那么它包含j个关键字(其中，j≤m-1)

(叶子结点：没有子结点的结点)

	p0 k1 p1 ... kj pj
	 |     |         |
	 v     v         v

	# ki:关键字，值唯一
	# pi:指向子树(ki<pi<ki+1)

B-Tree的插入如下：

* 插入的节点少于M-1个键值，直接插入
* 插入的节点键值已等于M-1，将节点分为二

### B+Tree的特点

B+Tree是B-Tree的变种，不同点如下：

* 非叶子结点的子树指针与关键字个数相同
* 为所有叶子结点增加一个链指针
* 所有关键字都在叶子结点出现

非叶子结点->Index Page
叶子结点 ->Leaf Page

非叶子节点不存储关键字，仅作为区间的区分。同时叶子节点使用指针进行链接，方便进行区间查找。[这篇文章](http://blog.jobbole.com/114041/)举例了B+Tree中插入值时的分裂操作和旋转操作，可作为参考来理解B+Tree对IndexPage和LeafPage两种节点的操作。