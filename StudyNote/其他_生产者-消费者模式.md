# 生产者/消费者模式

## 构成

	生产者->缓冲区->消费者

### 为什么需要建立一个缓冲区？

* 解耦

假如由生产者直接调用消费者的函数，则生产者和消费者之间就会产生依赖(出现耦合)。当消费者发生变化的时候，生产者也需要做出对应的修改。

如果两者都依赖于缓冲区，耦合也就相应地降低了。

* 并发

函数之间的调用是同步的。假如由生产者直接调用消费者的函数，在消费者的函数产生返回值前，生产者需要一直等待(阻塞)。在使用生产者-消费者模式之后，两者都可以作为并发主体运作了。

* 解决忙闲不均

 例，当生产者制造数据的速度大于消费者处理数据的速度时，多余的数据就可以先放在缓冲区中。

## 数据单元

### 数据单元的特性

* 关联到业务对象
* 完整性
* 独立性 数据单元之间不相互依赖
* 颗粒度 数据单元的内容 (**概念待确认**)

## 队列缓冲区

### 基于线程的并发

生产者将制造的数据push入队列，消费者从队列中pop数据并处理。

* 内存分配

在这种情况下，会这设计到频繁的堆内存分配和释放。

* 线程的同步和互斥

两个线程共用一个队列的情况下，会涉及到线程之间的同步、互斥、死锁等问题。

* 优点

在数据量不大的情况下，队列缓冲有逻辑清晰、代码简单、维护方便的特点。

### 基于进程的并发

跨进程的生产者／消费者模式，非常依赖于具体的进程间通讯（IPC）方式。常见的PIC方式如下：

#### 匿名管道

管道：生产者进程在管道的写端放入数据，消费者进程在管道的读端取出数据。

管道总体和线程中的队列类似，但是在使用管道的时候不需要担心线程安全、内存分配等问题，在进程中会由操作系统进行调配。

管道分为命名管道和匿名管道。不同操作系统下的命名管道，API接口和功能实现上的差异较大。不同操作下系统下的匿名管道，API接口也存在差异，但是可以通过使用标准输入和标准输出(studio)来进行数据的写入的读出，然后利用shell的管道符关联生产者进程和消费者进程。

* 管道方式优点

	* 不同操作系统都支持使用shell操作管道符，支持跨平台；
	* 不同编程语言可以操作studio，支持跨编程语言；
	* 由操作系统来对内存进行调配，降低开发成本和调试成本。

* 管道方式的缺点
	
	* 消费者进程和生产者进程需要在同一台机器上，不能实现跨机器；
	* 适用于一对一，但在一对多或多对一的情况下性能不佳；
	* 生产者和消费者的进程不可见，无法由程序对管道的尺寸等进行修改；
	* 只能进行单向传输。

#### SOCKET

SOCKET的优点：
	
* 支持跨机器，可以实现分布式
* 便于扩展为多对一或一对多
* 可以设置阻塞和非阻塞方式
* 支持双向通信，生产者可以接受消费者的反馈

SOCKET在实现上比shell管道复杂，但现成的SOCKET通讯库和框架，比如C++的ACE库、Python的Twisted。在解决跨机器通讯时的网络原因时，可以将生产者-消费者模式作为线程引入到生产者-消费者进程中。

	生产者进程->TCP库/框架/API->消费者进程
	生产者进程 = [生产线程->发送缓冲区->发送线程]
	消费者进程 = [接受线程->接受缓冲区->消费线程]

## 环形缓冲区

## 参考资料

* [博客](https://blog.csdn.net/kaiwii/article/details/6758942)