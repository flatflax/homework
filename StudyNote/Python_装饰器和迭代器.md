## 装饰器 decorator

* python函数

* python函数的作用域 or 函数的命名空间

在函数体遇到变量时，python会首先在函数的命名空间中寻找变量名

	globals 	# 所有python能识别的变量字典
	locals		# 局部变量

* 变量解析规则和生命周期

在函数体内创建变量，总是会创建一个新的局部变量。但是在函数体内访问变量时，则是先在局部作用域（函数的作用域）内进行查找，然后再在整个外层作用域中寻找匹配。在函数体内对全局变量赋值是无法实现的。

函数体的命名空间，在函数被调用的时候重新创建。在函数结束时被销毁。

* 函数的形参和实参

形参在函数中为局部变量。我们可以给函数定义位置参数和关键字参数。其中位置参数的值不能为空。

* 内建函数

Python允许创建内嵌函数。在函数的内建函数中，作用域和生命周期的相关规则依然适用。

* 函数也是对象

在Python中，函数也是对象，函数也可以包含属性。因此可以将函数A作为参数传入函数B中，也可以将函数A作为函数B的结果返回。同时也可以返回一个函数标签的变量（它没有被调用）。

	>>> def outer():
	...     def inner():
	...         print "Inside inner"
	...     return inner # 1
	...
	>>> foo = outer() #2
	>>> foo # doctest:+ELLIPSIS
	<function inner at 0x...>
	>>> foo()
	Inside inner

根据函数的作用域和生命周期，在`outer()`中定义`inner()`，每次当`outer()`被调用时，就会重新定义一次`inner()`。但是如果`outer()`没有返回`inner()`，那么当`outer()`结束时，`inner()`的生命周期就会结束。

但是当我们将`inner()`作为`outer()`的返回值时（这时它帮你改没有被调用），我们会发现`foo`中包含`inner`。

* 闭包

下面的代码中，`x`是`outer`中的局部变量。`inner`中需要打印`x`。`outer`返回`inner`。

	>>> def outer():
	...     x = 1
	...     def inner():
	...         print x # 1
	...     return inner
	>>> foo = outer()
	>>> foo.func_closure # doctest: +ELLIPSIS
	(<cell at 0x...: int object at 0x...>,)

由于Python支持闭包特性，因此非全局作用域定义的`inner`包含了外层作用域变量。这个特性可以通过查看`inner`的`func_closure`属性。

* 装饰器

装饰器其实就是一个以函数作为参数并返回一个替换函数的可执行函数。这样就可以将一些需要重复使用的，而且又不希望对原函数进行修改的新的函数，使用装饰器包装，并应用到所有需要的函数中。

在python中，支持通过在函数定义前添加`@`和装饰器名，来实现对函数的包装。

* `args`和`*kwargs`

当编写可以可以适用于任何函数的装饰器的时候，需要接受该装饰器所包装的任何函数中的所有调用信息，并在调用被包装的函数时，将传递给装饰器的参数全部传给该函数。

	>>> def one(*args):
	...     print args # 1
	>>> one()
	()
	>>> one(1, 2, 3)
	(1, 2, 3)
	>>> def two(x, y, *args): # 2
	...     print x, y, args
	>>> two('a', 'b', 'c')
	a b ('c',)

如上所述，`one`中会打印所有传递给它的参数，而`two`中，`args`捕捉了额外参数，并将其打印出来。在定义函数时，带`*`的变量名，意味着任何传递给函数的额外位置参数都是以`*`开头的。在调用函数时，以`*`开头的该变量内容需被取出用做位置参数。

`*args`可以表示在调用函数时从迭代器中取出位置参数， 也可以表示在定义函数时接收额外的位置参数。`**kargs`可以表示字典和键值对。

参考链接：
[简单理解Python装饰器](http://python.jobbole.com/85056/)

## 迭代器 iterator

* 判断是否为可迭代对象

	from collections import Iterable
	isinstance([],Iterable)

string、list、tuple、dict、set都是可迭代对象。

* 可迭代协议

可以被迭代要满足的要求就叫做可迭代协议。可迭代协议的定义，就是内部实现了`__iter__`方法。可以使用该方法将非迭代器的可迭代对象变为迭代器。

* 迭代器协议

所有迭代器都是可迭代对象，但可迭代对象不一定是迭代器。迭代器比起非迭代器的可迭代对象，多实现了三个方法：

	__length_hint__()	# 获取迭代器的长度
	__next__()			# 获取下一个值
	__setstate__()		# 根据索引值指定从哪里开始迭代

调用迭代器的`next`方法可以一直获取下一个，直到最后抛出StopIteration错误，表示无法继续返回下一个值。迭代器的`next`方法是惰性计算，只有在被调用的时候才会计算下一个值。

## 生成器 generator

一个包含`yield`关键字的函数就是一个生成器函数，生成器本质是一个迭代器，所以拥有`__iter__`方法和`__next__`方法

特点：惰性运算,开发者自定义

使用生成器的优点：

1. 延迟计算，一次返回一个结果。也就是说，它不会一次生成所有的结果，这对于大数据量处理，将会非常有用。

2. 提高代码可读性